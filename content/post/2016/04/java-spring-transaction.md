+++
date = "2016-04-03T13:48:48+08:00"
description = "Spring中的事务管理"
draft = true
tags = ["Spring","事务"]
title = "Spring中的事务管理"
topics = ["Java"]

+++

Spring中的事务管理通常有两种方式,即编程式事务管理和声明式事务管理。在学习Spring中的事务管理前,
首先需要了解几个事务中的概念。

## 关于事务的一些概念

事务本身持有4个限定属性,即**原子性(Atomicity)**、**一致性(Consistency)**、**隔离性(Isolation)**和**持久性(Durability)**,
这也就是常说的事务ACID属性。<!--more-->

关于其中的**隔离性**,一般可以分成以下4种隔离级别:

+ Read Uncommited。这是最低的隔离级别。该隔离级别的事务可以读取另一个事务没有提交的最新结果,这样就会导致以下几个问题:
 - 脏读(Dirty Read)。如果一个事务对数据进行了更新,但事务还没有提交,另一个事务就可以看到该事务没有提交的更新结果。
 这样造成的问题是,如果第一个事务回滚,那么第二个事务所看到的之前的数据就是一笔脏数据。
 - 不可重复读取(Non-Repeatable Read)。不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取,每次读取的结果都不同。
 - 幻读(Phantom Read)。幻读是指同样一个查询在整个事务过程中多次执行后,查询所得的结果集是不一样的。幻读针对的是多笔记录。
 
+ Read Committed。通常,这是大多数数据库采用的默认隔离级别。在该隔离级别下,一个事务的更新操作结果只有在该事务提交之后,另一个
事务才可能读取到同一笔数据更新后的结果。这样可以避免脏读的问题,但是无法避免不可重复读取和幻读。

+ Repeatable Read。Repeatable Read隔离级别可以保证在整个事务的过程中,对同一笔数据的读取结果是相同的。该隔离级别避免了脏读和
无法重复读取的问题,但是无法避免幻读。

+ Serializable。这是最严格的隔离级别。所有的事务操作都必须依次顺序执行,可以避免其他隔离级别遇到的所有问题,是最为安全的隔离级别。
但是也是性能最差的隔离级别。

不同的隔离级别设置会对系统的并发性以及数据一致性造成不同的影响。总地来说,隔离级别与系统并发性成反比,与数据一致性成正比。


在事务中还需要了解的一个概念是事务的传播行为。在Spring中,针对事务的传播行为,``TransactionDefinition``提供了以下几种选择:

+ PROPAGATION_REQUIRED。如果当前存在一个事务,则加入当前事务,如果不存在任何事务,则创建一个新事务。总之,至少要保证在一个事务中运行。
PROPAGATION_REQUIRED通常作为默认的事务传播行为。

+ PROPAGATION_SUPPORTS。如果当前存在一个事务,则加入当前事务,如果当前不存在事务,则直接执行。对于一些查询方法来说,这是比较合适的传播行为。

+ PROPAGATION_MANDATORY。强制要求当前存在一个事务,如果不存在,则抛出异常。如果某个方法需要事务的支持,但本身又不管理事务提交或者回滚,那么
比较适合PROPAGATION_MANDATORY。

+ PROPAGATION_REQUIRES_NEW。不管当前是否存在事务,都会创建新的事务。如果当前存在事务,会将当前的事务挂起。
如果某个业务对象所做的事情不想影响到外层的事务,PROPAGATION_REQUIRES_NEW应该是合适的选择。

+ PROPAGATION_NOT_SUPPORTED。不支持当前事务,而是在没有事务的情况下执行。如果当前存在事务的话,当前事务原则上将被挂起,
但这要看对应的``PlatformTransactionManager``实现类是否支持事务的挂起。

+ PROPAGATION_NEVER。永远不需要当前存在事务,如果存在当前事务,则抛出异常。

+ PROPAGATION_NESTED。如果存在当前事务,则在当前事务的一个嵌套事务中执行,否则与PROPAGATION_REQUIRED的行为类似,即创建新的事务。
类似与``savePoint``。

## Spring中的编程式事务管理



